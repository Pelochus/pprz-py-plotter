#!/usr/bin/env python3

# TODO: Put info here

'''
    Proposed data structure:
    data_dict[id] = named_tuple[n].(timestamp, var1, var2...)

    (Suppose INS freq = 0.1 s, 10 Hz)
    Example for id = 2, field INS:

    data[2] -> INS[0] -> (0.1, x, y, z, vx, vy, vz, ax, ay, az)
    data[2] -> INS[1] -> (0.2, x, y, z, vx, vy, vz, ax, ay, az)
    ...
    data[2] -> INS[11] -> (1.2, x, y, z, vx, vy, vz, ax, ay, az)

    Say, we want to graph the x position of INS:

    for i in range(0, data[2].INS.size):
        x = data[2].INS[i].x
        print(x)
'''

# Related Links:
# https://numpy.org/doc/stable/reference/generated/numpy.array.html
# https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html

import argparse
import numpy
import os

from collections import namedtuple
from lxml import etree

# Constants
MESSAGES_BLOCK = 'protocol/msg_class'
MESSAGES_OUTPUT_FILENAME = 'telemetry_messages.xml'
DATA_OUTPUT_FILENAME = 'data_log.txt'
TMP_DIR = './tmp'

MESSAGES_TYPES = {} # Data structures (named tuples) for each message
DATA_DICT = {} # Data dictionary, with up to N (number of UAVs, IDs) MESSAGE_TYPES

def clean_and_format_xml(xml):
    # Remove comments and recover from errors
    parser = etree.XMLParser(remove_comments=True, recover=True, remove_blank_text=True)
    root = etree.fromstring(xml, parser)

    formatted_xml = etree.tostring(root, pretty_print=True, encoding='unicode')
    
    return formatted_xml

'''
    Simplify the .log file to a file which only contains the telemetry block
    This file will make easier to extract the vars for each message
'''
def make_messages_xml(logfile):
    parser = etree.XMLParser(remove_comments=True, recover=True)
    root = etree.fromstring(logfile, parser)

    # Find msg_class NAME = telemetry and ID = 1
    telemetry_xml = ''
    for msg_class in root.findall(MESSAGES_BLOCK):
        if msg_class.get('NAME') == 'telemetry' and msg_class.get('ID') == '1':
            telemetry_xml = etree.tostring(msg_class, encoding='unicode')
            break
        else:
            print("No telemetry messages found in the logfile!")
            exit(1)

    telemetry_xml = clean_and_format_xml(telemetry_xml)
        
    # Save the msg_class block in a file
    output_file = os.path.join(TMP_DIR, MESSAGES_OUTPUT_FILENAME)
    if telemetry_xml:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(telemetry_xml)
    
    if args.verbose:
        print("Telemetry messages block XML saved in", output_file)

'''
    Create data structures for each message
    
    Examples:
    INS(timestamp, x, y, z, vx, vy, vz, ax, ay, az)
    GVF(timestamp, error, traj, s, ke, p)
'''
def create_structs():
    # Parse the telemetry messages XML
    with open(os.path.join(TMP_DIR, MESSAGES_OUTPUT_FILENAME), 'r', encoding='utf-8') as f:
        parser = etree.XMLParser(remove_comments=True, recover=True)
        root = etree.fromstring(f.read(), parser)

        for msg in root.findall('message'):
            msg_name = msg.get('NAME')
            msg_id = msg.get('ID')
            msg_vars = msg.findall('field')

            # Create a named tuple for each message
            fields = ['TIMESTAMP'] # To differentiate from a possible timestamp field inside the message
            for var in msg_vars:
                fields.append(var.get('NAME'))

            # Create the named tuple
            MESSAGES_TYPES[msg_name] = namedtuple(msg_name, fields)

            if args.verbose:
                print("Created named tuple for message", msg_name, "with id", msg_id, "and fields", fields)

'''
    Parse the datafile
'''
def parse_datafile(datafile):
    for line in datafile:
        # Split by spaces
        parts = line.split()
        
        # Extract data
        timestamp = float(parts[0])
        id = int(parts[1])
        name = parts[2]
        data = parts[3:]

        # Create the inner data dictionary for the id
        if id not in DATA_DICT:
            DATA_DICT[id] = {}
        
        # Create the inner array for the inner dict
        if name not in DATA_DICT[id]:
            DATA_DICT[id][name] = []
         
        # Save using the id and name. Previously check if name is saved (if it's a telemetry message)
        if name in MESSAGES_TYPES:
            linedata = MESSAGES_TYPES[name](timestamp, *data)
            DATA_DICT[id][name].append(linedata)

            if args.verbose:
                output_file = os.path.join(TMP_DIR, DATA_OUTPUT_FILENAME)
                with open(output_file, 'a', encoding='utf-8') as f:
                    f.write(str(linedata))
                    f.write('\n')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="pprz-py-plotter")
    parser.add_argument('datafile', help="Paparazzi's log .data file")
    parser.add_argument('logfile', help="Paparazzi's log .log file")
    parser.add_argument('-v', '--verbose', dest='verbose', default=False, action='store_true', help="Display debug messages")
    args = parser.parse_args()

    os.makedirs(TMP_DIR, exist_ok=True)

    # Parse logfile for messages and its variables
    with open(args.logfile, 'r', encoding='utf-8') as logfile:
        make_messages_xml(logfile.read())
        create_structs()

        if args.verbose:
            for n in MESSAGES_TYPES:
                print(n, MESSAGES_TYPES[n])

        # Example of usage
        '''
            b = MESSAGES_TYPES["PONG"](1)
            print(b, b.TIMESTAMP)
        '''

    # Convert datafile to numpy arrays
    with open(args.datafile, 'r', encoding='utf-8') as datafile:
        parse_datafile(datafile)